PackageManagerService
 packages.xml保存着所有安装应用的列表
packages.list 保存着非系统自带的应用

涉A涉G整改无法开机


问题背景是无法获取GMS更新后的应用，为了剥离对GMS应用的依赖，把GMS相关的应用移到另外的一个分区，系统在进行升级的时候，可以不依赖GMS应用的状态

getRequiredInstallerLPr


从packages.xml里面读取了PackageSettingr后，针对line应用，做特殊处理，按系统应用的标准来进行处理，签名不一致的不会影响到正常安装



ActivityTaskManagerService

chrome黑屏问题

chrome黑屏，进入freeform分屏模式后，用手势导航进入recent,然后退出到桌面，点击桌面chrome图标，出现黑屏
刚开始分析的时候，先dumpsys了Activity的信息，发现当前chrome界面的Activity宽和高都是-1，bouns都是0，从Log里面看，在手势进入Recent时，chrome的Activity没有走onPause 和 onStop，而是在下一次打开的时候才走onPause ，然后走到了OnResume里面，生命周期不正常

然后对比测试其它应用，用计算器试了下，在手势进入Recent时，计算器走到了onPause方法


找到了和正常情况的差异点后，在onPause的地方加log,看正常的是走到ActivityIdleInternalLocked，在Idle消息中完成onPause 和onStop的

    正常时，立即发送idle消息，而异常时，这里走的是scheduleIdleTimeoutLocked，没有立即发送idle消息


然后在代码里面找，走scheduleIdleTimeoutLocked和scheduleIdleLocked方法在哪一个判断条件里面触发的，找到了addToStopping方法

里面的idleDelayed变量值为true,进一步看此方法调用栈里面的上一步，makeInvisible里面传入的值，是根据应用是否支持pip来判断的，由于chrome支持pip,所以传入的值是true，对比计算器不支持pip，所以传入的是false

对比Google原生代码逻辑就是如此，为了让应用可以在OnPuase里面进入pip，给了一些延时给应用来处理，时间是10S，通过测试也可以确认，当下一次启动chrome的间隔超过10s，不会出现黑屏



问题的根因就在这个地方，对比测试其它支持pip的应用，也会出现这种问题


从整个调用栈来看，是从手动导航服务里面跨进程调用ActivityTaskManagerService里面的方法，设置ActivityRecord的可见性，最终走到了ActvityStack的makeInvisible方法

在最新的主干分支上，手势导航的逻辑重构了，没有此问题，在商用分支上，为了稳定性考虑，采用了退避方案处理，针对此种场景添加特殊处理，在checkEnterPictureInPictureState方法里面，针对出问题的场景的各种状态统一判断，在此场景下返回false，然后进行测试



调用到ActivityStack里面的makeInVisible方法，将当前ActivityRecord加入到Stopping列表里面，

RoleManagerService
roles.xml

system.xml
secure.xml
global.xml




