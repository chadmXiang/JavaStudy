Java Tutorials
https://www.oracle.com/java/technologies/javase/java-tutorial-downloads.html




函数式编程概念介绍

函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。

比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。

在函数式编程中，函数是第一类对象(第一类公民)，意思是说一个函数，既可以作为其它函数的参数（输入值），也可以从函数中返回（输入值），被修改或者被分配给一个变量。

第一类对象不一定是面向对象程序设计所指的物件，而可以指任何程序中的实体。一般第一类对象所特有的特性为：
可以被存入变数或其他结构
可以被作为参数传递给其他函数
可以被作为函数的返回值
可以在执行期创造，而无需完全在设计期全部写出
即使没有被系结至某一名称，也可以存在



函数式编程的理论基础是Lambda演算，其本身是一种数学的抽象但不是编程语言


函数式编程关心数据的映射，命令式编程关心解决问题的步骤



响应式编程

响应式编程使用三个核心概念：数据流，函数式编程和异步观察。

反应式编程(reactive programming )是基于 函数式编程(functional programming )的, 所以也可以叫做 函数反应式编程 (functional reactive programming)




FRP基本上就是面向异步事件流的编程了，这个异步事件流叫：Observable，一般叫：Stream
Stream就是一个 按时间排序的Events(Ongoing events ordered in time)序列
Stream是不可变(Immutability)的，任何操作都返回新的Stream, 且它是一个Monad（它有map和flatMap方法）。
FRP的关注点在Stream，而FP的关注点在(Type, Operate)，Stream -> (Type, Operate)是一种泛化（generic），(Type, Operate) -> Stream 是一种派生。
RP本身是建立于观察者模式之上的一种编程范式（级别同MV*），FP则更偏向底层解决一般化问题。引用wiki上的一句话：
Functional reactive programming (FRP) is a programming paradigm for reactive programming on functional programming.

https://www.zhihu.com/question/36431501
https://stackoverflow.com/questions/30216979/difference-between-java-8-streams-and-rxjava-observables
https://www.zhihu.com/question/28292740

同样由于变量不可变,纯函数编程语言无法实现循环,这是因为For循环使用可变的状态作为计数器,而While循环或DoWhile循环需要可变的状态作为跳出循环的条件.因此在函数式语言里就只能使用递归来解决迭代问题,这使得函数式编程严重依赖递归.
https://developer.ibm.com/zh/articles/j-understanding-functional-programming-1/


Java Streams

把JSR335 标准文档下载下来

https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html
https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html


Java 8 中的流表示的是元素的序列。流中的元素可能是对象、int、long 或 double 类型。流作为一个高层次的抽象，并不关注流中元素的来源或是管理方式

流的操作可以顺序执行或并行执行, 后者可以获得比前者更好的性能。但是如果实现不当，可能由于数据竞争或无用的线程同步，导致并行执行时的性能更差。一个流是否会并行执行，可以通过其方法 isParallel() 来判断。根据流的创建方式，一个流有其默认的执行方式。可以使用方法 sequential() 或 parallel() 来将其执行方式设置为顺序或并行。


一个流的相遇顺序（encounter order）是流中的元素被处理时的顺序。流根据其特征可能有，也可能没有一个确定的相遇顺序。举例来说，从 ArrayList 创建的流有确定的相遇顺序；从 HashSet 创建的流没有确定的相遇顺序。大部分的流操作会按照流的相遇顺序来依次处理元素。如果一个流是无序的，同一个流处理流水线在多次执行时可能产生不一样的结果。比如 Stream 的 findFirst() 方法获取到流中的第一个元素。如果在从 ArrayList 创建的流上应用该操作，返回的总是第一个元素；如果是从 HashSet 创建的流，则返回的结果是不确定的。对于一个无序的流，可以使用 sorted 操作来排序；对于一个有序的流，可以使用 unordered() 方法来使其无序。

Spliterator 需要绑定到流之后才能遍历其中的元素

流操作可以是有状态或无状态的

在对流进行处理时，不同的流操作以级联的方式形成处理流水线。一个流水线由一个源（source），0 到多个中间操作（intermediate operation）和一个终结操作（terminal operation）完成。

流中间操作在应用到流上，返回一个新的流。下面列出了常用的流中间操作：
map：通过一个 Function 把一个元素类型为 T 的流转换成元素类型为 R 的流。
flatMap：通过一个 Function 把一个元素类型为 T 的流中的每个元素转换成一个元素类型为 R 的流，再把这些转换之后的流合并。The Java Stream flatMap() methods maps a single element into multiple elements
filter：过滤流中的元素，只保留满足由 Predicate 所指定的条件的元素。
distinct：使用 equals 方法来删除流中的重复元素。
limit：截断流使其最多只包含指定数量的元素。
skip：返回一个新的流，并跳过原始流中的前 N 个元素。
sorted：对流进行排序。
peek：返回的流与原始流相同。当原始流中的元素被消费时，会首先调用 peek 方法中指定的 Consumer 实现对元素进行处理。
dropWhile：从原始流起始位置开始删除满足指定 Predicate 的元素，直到遇到第一个不满足 Predicate 的元素。
takeWhile：从原始流起始位置开始保留满足指定 Predicate 的元素，直到遇到第一个不满足 Predicate 的元素。

takeWhile和dropWhile在jdk 8 不能用？待确认

常见的终结操作
foreach
foreachOrdered
reduce
count  返回流中元素的数量
anyMatch
allMatch
noneMatch
findAny
findFirst
collect
min
max
toArray

reduce 操作把一个流约简成单个结果。约简操作可以有 3 个部分组成：
初始值：在对元素为空的流进行约简操作时，返回值为初始值。
叠加器：接受 2 个参数的 BiFunction。第一个参数是当前的约简值，第二个参数是当前元素，返回结果是新的约简值。
合并器：对于并行流来说，约简操作可能在流的不同部分上并行执行。合并器用来把部分约简结果合并为最终的结果。


https://developer.ibm.com/zh/articles/j-understanding-functional-programming-3/
file:///D:/work/Java/lambda-jsr335-final/api/api/java/util/stream/package-summary.html



https://stackoverflow.com/questions/19235606/understanding-spliterator-collector-and-stream-in-java-8

