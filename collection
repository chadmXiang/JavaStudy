https://www3.ntu.edu.sg/home/ehchua/programming/java/J5c_Collection.html
里面的结构图很好

数据结构：
数组    
数组在内存中顺序存储， 所以只要给出一个数组下标， 就可以读取到对应的数组元素，支持随机读取，
    根据下标查找是O(1);
    插入和删除是O(n)，
    适用于读多写少的场景

链表  
链表（linked list） 是一种在物理上非连续、 非顺序的数据结构， 由若干节点（node） 所组成。分单链表和双链表，一般实现的时候会使用head/tail指针来辅助实现相关的操作
    查找是O(n)
    插入和删除是O(1)
    适用于写多读少的场景
 
其它的数据结构以数组和链表为基础实现，集合框架和数组的差异主要有2点：
数组是固定大小的，支持基础类型和Object
集合支持动态扩容，不支持基础类型，只支持Object
Arrays are simple constructs with linear storage of fixed size and therefore they can only store a given number of elements. Arrays are built into the core of Java language and the array-related Java syntax is very easy and straightforward, for example the nth element of the array can be obtained as array[n-1]. Collections are more sophisticated and flexible. First of all, they are resizable: you can add any number of elements to a collection. A collection will automatically handle deletion of an element from any position

Arrays.sort --> DualPivotQuicksort.sort
< 47 使用插入排序
< 286 使用双轴快速排序
使用merge sort

Collections工具类，提供sort/binarySearch/reverse/rotate，其中排序使用的是List里面的默认排序，最终也是调用的Arrays.sort

Java Collection,框架抽象定义  
public interface Iterable<T>  支持迭代器
public interface RandomAccess   支持随机访问
public interface Comparator<T>   提供比较功能，用来给Collection进行排序
public interface Collection<E> extends Iterable<E>  Collection支持迭代器
// 由对应的子类实现来决定add方法里面是否限制某些元素(如重复元素和null)
public abstract class AbstractCollection<E> implements Collection<E>

List 
public interface List<E> extends Collection<E> 
以平时使用比较多的ArrayList为例来看,支持随机访问
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> 
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess

Set  不包含重复元素
public abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E>
在具体 实现类里面，HashSet支持add空元素，TreeSet不支持add空元素

Stack(FILO)
public class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess
public class Stack<E> extends Vector<E>
继承自Vector，Vector和ArrayList功能类似，但是Vector支持同步，ArrsyList不支持

Queue(FIFO)
public interface Queue<E> extends Collection<E>

Dueue(同时支持FILO和FIFO)
public interface Deque<E> extends Queue<E>

Tree
主要有2种TreeSet和TreeMap

Heap
public class PriorityQueue<E> extends AbstractQueue<E>
可以使用PriorityQueue来实现heap，默认实现是最小堆，
PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();

最大堆
PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return - Integer.compare(o1, o2);
    }
});

或者
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());

Map 支持键值对
public interface Map<K,V>
public abstract class AbstractMap<K,V> implements Map<K,V>
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>

http://tutorials.jenkov.com/java-collections/overview.html

|--> public interface List<E> extends Collection<E> 
|--> public interface Set<E> extends Collection<E> 
        |--> public abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E>
            |--> public class HashSet<E> extends AbstractSet<E> implements Set<E>
                add方法使用HashMap的map.put(e, PRESENT)，其中PRESENT为一个final对象，在HashMap.putVal方法里面，
                如果HashMap中不存在，则创建一个新的节点，最后返回一个null对象；
                如果存在，则更新value的值(此场景value值一直是PRESENT)，并返回之前的value值，即PRESENT对象
            |--> public class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>
            add方法使用TreeMap的m.put(e, PRESENT)，是一个红黑树，
                如果元素存在，即Tree中和元素和要插入的值相等，则更新并返回旧值
                如果不存在，则找到其parent节点，插入并返回null
        |--> public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> 
            |--> public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess


public interface Queue<E> extends Collection<E>
public interface Deque<E> extends Queue<E>


public class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess
public class Stack<E> extends Vector<E>




从LinkedList实现来看，继承自顺序访问的List，与ArrayList的差异在于未实现RandomAccess，不支持随机访问
public abstract class AbstractSequentialList<E> extends AbstractList<E>
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>

public interface SortedSet<E> extends Set<E>
SortedSet在添加元素的时候会进行排序

Set实现类不支持插入重复元素
TreeSet、TreeMap里面不支持添加null
ArrayList Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null


同步容器
    SynchronizedCollection<E> implements Collection<E>
    SynchronizedList<E> extends SynchronizedCollection<E> implements List<E>
    SynchronizedSortedSet<E> extends SynchronizedSet<E> implements SortedSet<E>
    同步容器Vector（线程安全的ArrayList） Hashtable (线程安全的HashMap)实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态

使用的时候需要注意：
对容器的复合操作，如迭代、跳转以及条件运算 需要额外的客户端加锁。
如果使用Iterator进行直接迭代，当其它线程并发修改容器的时候，会抛出ConcurrentModificationException；如果不希望在迭代期间对容器加锁，一种替代方案是clone容器，然后在副本上进行迭代。
如下场景可能会隐藏对容器的迭代操作，如toString、hashCode、equals 、containsAll 、removeAll 、retainAll等方法，会间接的进行迭代操作

并发容器，
ConcurrentHashMap 数组+链表(Tree)
get读取的时候没有加锁，使用的getObjectVolatile来判断是否存在
put 为空时不加锁，不为空时，对数组root node加锁，插入后再判断是否需要转化成tree
CopyOnWriteArrayList
get不加锁
add/set/remove加锁
ConcurrentLinkedQueue

BlockQueue提供了可阻塞的插入和获取等操作，在生产者-消费者这个设计模式下，阻塞队列非常有用



https://stackoverflow.com/questions/17432672/how-does-the-set-interface-guarantees-non-duplicates/17432744#17432744
https://stackoverflow.com/questions/8725387/why-is-there-no-sortedlist-in-java/8725470#8725470
https://stackoverflow.com/questions/14165325/is-there-a-heap-in-java
https://stackoverflow.com/questions/13361489/differences-between-an-array-and-any-collection-from-the-java-collection-framewo
https://www3.ntu.edu.sg/home/ehchua/programming/java/J5c_Collection.html

unsafe
https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html
https://stackoverflow.com/questions/5574241/why-does-sun-misc-unsafe-exist-and-how-can-it-be-used-in-the-real-world
https://stackoverflow.com/questions/16819234/where-is-sun-misc-unsafe-documented

