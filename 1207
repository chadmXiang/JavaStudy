Java 动态代理

https://developer.ibm.com/zh/articles/j-lo-proxy1/

Annotation APT

https://www.slideshare.net/ltearno/gwt-and-jsr-269s-pluggable-annotation-processing-api
file:///D:/work/Java/269.api/java.compiler-summary.html


RxJava
reactive-streams-jvm  定义了规范，4个主要接口
1、Publisher，发布者（生产者）
2、Subscriber，订阅者（消费者）
3、Subscription，订阅
4、Processor，处理者

RxJava 3 features several base classes you can discover operators on:
RxJavae 提供了5个基础类，来进行相关的操作
io.reactivex.rxjava3.core.Flowable: 0..N flows, supporting Reactive-Streams and backpressure
io.reactivex.rxjava3.core.Observable: 0..N flows, no backpressure,
io.reactivex.rxjava3.core.Single: a flow of exactly 1 item or an error,
io.reactivex.rxjava3.core.Completable: a flow without items but only a completion or error signal,
io.reactivex.rxjava3.core.Maybe: a flow with no items, exactly one item or an error.


一些基础概念介绍

UpStream DownStream

RxJava中的数据流包含一个源、0到多个中间操作，后面有一个数据消费者或操作组合(一个操作步骤step代表通过某种方式消费数据)
source
 
  .operator1()
 
  .operator2()
 
  .operator3()
 
  .subscribe(consumer)

operator2的左边的叫upstream,右边的叫downstream

Object in motion

在RxJava文件里面，item/emission/emits/event/signal/data/message 都是同义词，表示沿着数据流移动的对象

Backpressure

Flow Control流控的一种形式，表示一个操作步骤step可以处理多个事件(item).Backpressure允许控制数据流的内存使用量，特别是当一个操作步骤(step)不知道upstream会发送多少操作步骤item给它时。

在RxJava里面，Flowable被设计为支持backpressure,Observable被设计为不支持backpressure。
Single/Maybe/Completable不支持backpressure，因为总是有空间可以临时存储一个操作步骤


Assembly time 组装态

数据流在进行一系列中间操作(intermediate operators)前的准备,就是所谓的组装态
Flowable<Integer> flow = Flowable.range(1, 5)
.
.map(v -> v * v)
.
.filter(v -> v % 3 == 0)
;

在这个状态下，数据还没有开始流动，操作都没有执行

Subscription time 订阅态

当一个建立了内部调用链的flow调用subscribe()方法时的一个临时状态，叫订阅态

flow.subscribe(System.out::println)

这是触发订阅时的结果（参见doOnSubscribe）

Runtime 运行态

这是flow主动发出信息(item)、错误(error)或完成(completion)信号时的状态：


Simple backgroud computation

RxJava的一个常用的场景是执行一些计算工作、一个网络请求或一个后台线程，然后在UI线程上显示结果(或错误)

调用链是流式API，类似于Builder模式。RxJava里面的类型是不可变的，每次方法调用都会产生一个新的Flowable,带有新加的行为

Schedulers 调度器

RxJava里面的操作没有直接使用Thread或ExecutorService，而是使用Scheduler，抽象化了多线程操作，RxJava3提供了多个Scheduler工具类


Schedulers.computation(): Run computation intensive work on a fixed number of dedicated threads in the background. Most asynchronous operators use this as their default Scheduler.
Schedulers.io(): Run I/O-like or blocking operations on a dynamically changing set of threads.
Schedulers.single(): Run work on a single thread in a sequential and FIFO manner.
Schedulers.trampoline(): Run work in a sequential and FIFO manner in one of the participating threads, usually for testing purposes.

可以使用Schedulers.from(Executor)来会改传入定制的Executor


Concurrency within a flow


二进制位bit：计算机，所有的信息都是bit的形式存在，每个bit有0和1两种状态
字节byte:8个二进制位是一个byte
ASCII ：美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。规定了128个字符的编码，用一个byte来表示，只占用7个bit，最高为0
Unicode ：是一个符号集合，定义了符号的二进制代码，但是没有规定如何存储二进制代码
UTF-8：是Unicode的实现方式之一，使用变长的编码形式，可以用1-4个byte来表示一个符号

Unicode规范定义了，每个文件的最前面分别加入一个表示编码顺序的字符，用FEFF来表示，正好是2个字节。如果文本文件的头2个字节是FEFF，表示用的大头方式(第一个字节在前)，用FFFE的表示用的小头方式(第二个字节在前)

“通用字符集”（Universal Character Set，简称UCS）

Unicode和UCS是来自2个不同的组织，Unicode对集合添加了一些新的规则和规范

从File，从Socket


        // character streams read and write
        Reader reader;
        Writer wiWriter;
        
        // stream of bytes read and write
        InputStream inputStream;
        OutputStream outputStream;


        
        Charset.forName("UTF-8");
       // 
        String s = "这是一段中文字符串";
        byte[] b = s.getBytes("UTF-8");
        String n = new String(b,"UTF-8");
        
        Charset charset = Charset.forName("UTF-8");
        ByteBuffer byteBuffer = charset.encode(s);
        CharBuffer charBuffer = charset.decode(byteBuffer);



https://www.zhihu.com/question/39262026
https://developer.ibm.com/zh/articles/j-lo-chinesecoding/
base64 用来将binary data转换成字符流，更适用于网络传输场景
https://stackoverflow.com/questions/201479/what-is-base-64-encoding-used-for

https://stackoverflow.com/questions/9655181/how-to-convert-a-byte-array-to-a-hex-string-in-java

https://stackoverflow.com/questions/8860383/why-do-we-need-both-ucs-and-unicode-character-sets






