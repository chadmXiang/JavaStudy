Java 动态代理

https://developer.ibm.com/zh/articles/j-lo-proxy1/

Annotation APT

https://www.slideshare.net/ltearno/gwt-and-jsr-269s-pluggable-annotation-processing-api
file:///D:/work/Java/269.api/java.compiler-summary.html


RxJava
reactive-streams-jvm  定义了规范，4个主要接口
1、Publisher，发布者（生产者）
2、Subscriber，订阅者（消费者）
3、Subscription，订阅
4、Processor，处理者

RxJava 3 features several base classes you can discover operators on:
RxJavae 提供了5个基础类，来进行相关的操作
io.reactivex.rxjava3.core.Flowable: 0..N flows, supporting Reactive-Streams and backpressure
io.reactivex.rxjava3.core.Observable: 0..N flows, no backpressure,
io.reactivex.rxjava3.core.Single: a flow of exactly 1 item or an error,
io.reactivex.rxjava3.core.Completable: a flow without items but only a completion or error signal,
io.reactivex.rxjava3.core.Maybe: a flow with no items, exactly one item or an error.


一些基础概念介绍

UpStream DownStream

RxJava中的数据流包含一个源、0到多个中间操作，后面有一个数据消费者或操作组合(一个操作步骤step代表通过某种方式消费数据)
source
 
  .operator1()
 
  .operator2()
 
  .operator3()
 
  .subscribe(consumer)

operator2的左边的叫upstream,右边的叫downstream

Object in motion

在RxJava文件里面，item/emission/emits/event/signal/data/message 都是同义词，表示沿着数据流移动的对象

Backpressure

Flow Control流控的一种形式，表示一个操作步骤step可以处理多个事件(item).Backpressure允许控制数据流的内存使用量，特别是当一个操作步骤(step)不知道upstream会发送多少操作步骤item给它时。

在RxJava里面，Flowable被设计为支持backpressure,Observable被设计为不支持backpressure。
Single/Maybe/Completable不支持backpressure，因为总是有空间可以临时存储一个操作步骤


Assembly time 组装态

数据流在进行一系列中间操作(intermediate operators)前的准备,就是所谓的组装态
Flowable<Integer> flow = Flowable.range(1, 5)
.
.map(v -> v * v)
.
.filter(v -> v % 3 == 0)
;

在这个状态下，数据还没有开始流动，操作都没有执行

Subscription time 订阅态

当一个建立了内部调用链的flow调用subscribe()方法时的一个临时状态，叫订阅态

flow.subscribe(System.out::println)

这是触发订阅时的结果（参见doOnSubscribe）

Runtime 运行态

这是flow主动发出信息(item)、错误(error)或完成(completion)信号时的状态：


Simple backgroud computation

RxJava的一个常用的场景是执行一些计算工作、一个网络请求或一个后台线程，然后在UI线程上显示结果(或错误)

调用链是流式API，类似于Builder模式。RxJava里面的类型是不可变的，每次方法调用都会产生一个新的Flowable,带有新加的行为

Schedulers 调度器

RxJava里面的操作没有直接使用Thread或ExecutorService，而是使用Scheduler，抽象化了多线程操作，RxJava3提供了多个Scheduler工具类


Schedulers.computation(): Run computation intensive work on a fixed number of dedicated threads in the background. Most asynchronous operators use this as their default Scheduler.
Schedulers.io(): Run I/O-like or blocking operations on a dynamically changing set of threads.
Schedulers.single(): Run work on a single thread in a sequential and FIFO manner.
Schedulers.trampoline(): Run work in a sequential and FIFO manner in one of the participating threads, usually for testing purposes.

可以使用Schedulers.from(Executor)来会改传入定制的Executor


Concurrency within a flow



