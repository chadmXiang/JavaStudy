https://docs.oracle.com/javase/tutorial/java/annotations/index.html

JSR 175: A Metadata Facility for the JavaTM Programming Language
https://www.jcp.org/en/jsr/detail?id=175

JSR 269: Pluggable Annotation Processing API
https://www.jcp.org/en/jsr/detail?id=269

JSR 330: Dependency Injection for Java
https://www.jcp.org/en/jsr/detail?id=330


 There are two
kinds of interface declarations - normal interface declarations and annotation type
declarations (§9.6).

 An annotation type declaration specifies a new annotation type, a special kind
of interface type. 

注解是一个接口 

Annotation是一种元数据，提供了程序的一些信息，但不是程序的一部分，注解对有注解的程序执行没有任何影响

注解主要有3种用途

通知编译器，检查错误和警告
编译时和部署时处理，可以用注解来生成code/xml等
运行时处理，有些注解可以在运行时检查

注解的特点

用@来向编译器说明这是一个annotation

注解支持的返回值类型
• A primitive type
• String
• Class or an invocation of Class (§4.5)
• An enum type
• An annotation type
• An array type whose component type is one of the preceding types (§10.1)


注解可以包含有元素，可以有命名，也可以没有
@Author(
 
   name = "Benjamin Franklin",
 
   date = "3/27/2003"
)
)
c
class MyClass() { ... }

@SuppressWarnings(value = "unchecked")

void myMethod() { ... }

当只有一个元素的时候，可以写成
@SuppressWarnings("unchecked")
v
void myMethod() { ... }


注解的元素可以包含有默认值，使用关键字default
 @interface RequestForEnhancementDefault {
int id(); // No default - must be specified in each annotation
String synopsis(); // No default - must be specified in
// each annotation
String engineer() default "[unassigned]";
String date() default "[unimplemented]";
}

从Java 8开始，支持重复注解


Java语言里面内置的注解
@Deprecated, 
@Override,
@SuppressWarnings.

可以用来注解其它注解的称为元注解
Annotations that apply to other annotations are called meta-annotations

@Retention
RetentinPolicy.SOURCE  仅在代码层面参与，编译的时候被忽略
RetentionPolicy.CLASS  在编译的时候会保存，，保存在class文件中，但是被JVM忽略
RetentionPolicy.RUNTIME  在JVM里面保存，可以用在运行时
@Documented
@Target
ElementType.ANNOTATION_TYPE can be applied to an annotation type.
ElementType.CONSTRUCTOR can be applied to a constructor.
ElementType.FIELD can be applied to a field or property.
ElementType.LOCAL_VARIABLE can be applied to a local variable.
ElementType.METHOD can be applied to a method-level annotation.
ElementType.PACKAGE can be applied to a package declaration.
ElementType.PARAMETER can be applied to the parameters of a method.
ElementType.TYPE can be applied to any element of a class.

@Inherited
@Repeatable

https://checkerframework.org/


Java的注解本身对代码逻辑没有任何影响，如何使用完全由工具决定 

Java提供的使用反射API读取Annotation的方法包括：

判断某个注解是否存在于Class、Field、Method或Constructor：
Class.isAnnotationPresent(Class)
Field.isAnnotationPresent(Class)
Method.isAnnotationPresent(Class)
Constructor.isAnnotationPresent(Class)


Java Reflection makes it possible to inspect classes, interfaces, fields and methods at runtime, without knowing the names of the classes, methods etc. at compile time

// 获取Class对象
Class myObjectClass = MyObject.class;
// Class class = Class.forName("com.jenkov.myapp.MyObject");
// 获取属性
Field[] fields   = myObjectClass.getFields();
// 获取方法
Method[] methods = myObjectClass.getMethods();
// 获取构造方法
Constructor[] constructors = myObjectClass.getConstructors();
// 获取注解
Annotation[] annotations = aClass.getAnnotations();
// 获取package
Package package = aClass.getPackage();
// 获取实现的接口
Class[] interfaces = aClass.getInterfaces();
// 获取父类
Class superclass = aClass.getSuperclass();
// 获取Modifiers(public / static/private/protected)
int modifiers = aClass.getModifiers();
// 获取构造方法的参数
Class[] parameterTypes = constructor.getParameterTypes();

一般用法

1.获取Class对象
       Class myObjectClass = MyObject.class;
       Class class = Class.forName("com.jenkov.myapp.MyObject");

2.获取需要反射调用的属性或方法
Field[] fields   = myObjectClass.getFields();
Field field = aClass.getField("someField");



Method[] methods = myObjectClass.getMethods();
Class[] parameterTypes = method.getParameterTypes();
Class returnType = method.getReturnType();

Method method = MyObject.class.getMethod("doSomething", String.class);



3.创建一个Class的实例对象

        MyObject objectInstance = new MyObject();



Constructor constructor = MyObject.class.getConstructor(String.class);


MyObject myObject = (MyObject)
 
        constructor.newInstance("constructor-arg1");


4.通过实例对象来访问方法或属性，如果是私有的，需要先setAccessible为true

Field field = aClass.getField("someField");


Object value = field.get(objectInstance);


field.set(objetInstance, value);

Field privateStringField = PrivateObject.class.
 getDeclaredField("privateString");


privateStringField.setAccessible(true);
String fieldValue = (String) privateStringField.get(privateObject);






getDeclaredMethods能获取private方法，getMethods不能，注意类似方法的获取范围是不一样的
在调用方法的时候，如果方法是static的，传入的实例对象是null;如果是非static方法，需要传入一个实例对象
访问私有变量或私有方法时，需要调用setAccessible修改访问权限


Class aClass = TheClass.class;
A
Annotation[] annotations = aClass.getAnnotations();

Class aClass = TheClass.class;
A
Annotation annotation = aClass.getAnnotation(MyAnnotation.class);

Annotation[] annotations = method.getDeclaredAnnotations();
Annotation annotation = method.getAnnotation(MyAnnotation.class);

Annotation[][] parameterAnnotations = method.getParameterAnnotations();

Class[] parameterTypes = method.getParameterTypes();

Annotation[] annotations = field.getDeclaredAnnotations();
Annotation annotation = field.getAnnotation(MyAnnotation.class);



反射泛型
http://tutorials.jenkov.com/java-reflection/generics.html

int[] intArray = (int[]) Array.newInstance(int.class, 3);




Array.set(intArray, 0, 123);

Array.set(intArray, 1, 456);

Array.set(intArray, 2, 789);



动态代理
InvocationHandler handler = new MyInvocationHandler();
M
MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
 
                            MyInterface.class.getClassLoader(),
 
                            new Class[] { MyInterface.class },
 
                            handler);


http://tutorials.jenkov.com/java/annotations.html
http://tutorials.jenkov.com/java-reflection/annotations.html

https://www.jianshu.com/p/506dcd94d4f9


In software engineering, dependency injection is a technique in which an object receives other objects that it depends on. These other objects are called dependencies.

Dependency injection is one form of the broader technique of inversion of control. A client who wants to call some services should not have to know how to construct those services


在运行时（Runtime）通过反射机制运行处理的注解，而是讨论在编译时（Compile time）处理的注解。


注解处理器（Annotation Processor）是javac的一个工具，它用来在编译时扫描和处理注解（Annotation）

注解处理器是运行它自己的虚拟机JVM中。是的，你没有看错，javac启动一个完整Java虚拟机来运行注解处理器

注解是不能继承的

http://hannesdorfmann.com/annotation-processing/annotationprocessing101

https://www.race604.com/annotation-processing/

