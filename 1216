数学运算符和聚合运算符

Backpressure

Backpressue是指一个Flowable管道处理中，有些异步状态无法及时处理产出的值，需要一种方式来告诉upstream降低生产数据的节奏，本质上是一种flow control策略。

在Rxjava3里面，提供了5中处理策略，定义在BackpressureStrategy里面
MISSING onNext事件没有任何buffer缓存，或丢弃，downstream必须处理这些overflow.适用场景：
ERROR  发送一个MissingBackpressureException以防止downstream无法继续处理
BUFFER 缓存所有onNext值到downstream消费，默认Buffer大小是128，可以修改
DROP 如果downstream无法处理，丢弃最近的onNext事件
LATEST 仅保存最新的onNext值，如果downstream无法处理，则覆写先前的值


FlowableEmitter

SerializedEmitter implements FlowableEmitter

BaseEmitter<T> extends AtomicLong implements FlowableEmitter<T>, Subscription 

abstract static class NoOverflowBaseAsyncEmitter<T> extends BaseEmitter


MissingEmitter<T> extends BaseEmitter<T>

ErrorAsyncEmitter<T> extends NoOverflowBaseAsyncEmitter

BufferAsyncEmitter<T> extends BaseEmitter

LatestAsyncEmitter<T> extends BaseEmitter

DropAsyncEmitter<T> extends NoOverflowBaseAsyncEmitter

BackpressureHelper



onBackpressureXXX操作


大部分开发者遇到backpressure是当应用出问题抛出MissingBackpressureException异常，而且异常通常指向于observeOn操作上。实际的原因是使用了不支持backpressure的PublishProcessor、timer()、interval、或者通过create自定义的操作

有几种方式可以处理此场景：

1.增加buffer的大小

有时overflow是因为快速的事件产生。用户突然快速点击屏幕，observeOn在android默认大小是16

在最新的Rxjava里面，开发者可以显式的指定缓存大小，相关的参数



然而在通常场景下，只设置一个临时的大小也会出现overflow的情况，当源数据生产了超出预测缓存大小时，在这种场景下，可以使用如下操作


onBackPressureBuffer系列方法

传入的参数都不同，最终都是创建FlowableOnBackpressureBuffer

final int bufferSize;  缓存大小
final boolean unbounded;  如果为true，表示缓存大小被解释为内部无界缓存的island值
final boolean delayError; 如果为true，表示一个Flowable里面的exception会延迟发送，直到缓存里面的所有元素都被downstream消费掉；为false时，会直接将Excetion通知到downstream,忽略缓存的数据
final Action onOverflow; 


if (unbounded) {
    q = new SpscLinkedArrayQueue<>(bufferSize);  // 可以调整大小
} else {
    q = new SpscArrayQueue<>(bufferSize);  // 大小固定
}

onBackPressureDrop

Drops items from the current Flowable if the downstream is not ready to receive new items (indicated by a lack of Subscription.request(long) calls from it).

如果downstream还没有准备好接收新的事件(通过Subscription.request调用的缺失来表示);从当前Flowable里面丢弃


If the downstream request count hits 0 then the resulting Flowable will refrain from calling onNext until the Subscriber invokes request(n) again to increase the request count.

如果downstream request为0，则由此产生的Flowable将不调用onNext，直到Subscriber再次调用request(n)来增加请求计数。

带参数onDrop the action to invoke for each item dropped, should be fast and should never block.

FlowableOnBackpressureDrop

onBackpressureLatest

Drops all but the latest item emitted by the current Flowable if the downstream is not ready to receive new items (indicated by a lack of Subscription.request(long) calls from it) and emits this latest item when the downstream becomes ready.


如果downstream还没有准备好接收新的事件(通过Subscription.request调用的缺失来表示);从当前Flowable里面丢弃除最新之外的事件，当downstream准备好的时候，把最新的事件发给downstream

Its behavior is logically equivalent to blockingLatest() with the exception that the downstream is not blocking while requesting more values.



backpressured 数据源的创建方式

Flowable.just 适用于

Returns a {@code Flowable} that signals the given (constant reference) item and then completes.

Note that the item is taken and re-emitted as is and not computed by any means by {@code just}. Use {@link #fromCallable(Callable)}
* to generate a single item on demand (when {@link Subscriber}s subscribe to it).

返回一个Flowable,然后把给定的常量引用事件发送出去，然后结束。注意这个事件被获取，然后重新发送，just不会改这个事件。使用fromCallable近需来生成单个事件

FlowableJust

@Override
public void request(long n) {
    if (!SubscriptionHelper.validate(n)) {
        return;
    }
    if (compareAndSet(NO_REQUEST, REQUESTED)) {
        Subscriber<? super T> s = subscriber;
        // 把事件发送给订阅者
        s.onNext(value);
        if (get() != CANCELLED) {
            // 发送完成事件
            s.onComplete();
        }
    }

}

just方法里面有多个参数的时候，内部实现是通过formarray




FlowableFromCallable

Returns a Flowable that, when a Subscriber subscribes to it, invokes a function you specify and then emits the value returned from that function.


返回一个Flowable，当一个Subscriber订阅的时候，会调用指定的Callable，然后返回Callable的执行结果并作为事件发送出去

This allows you to defer the execution of the function you specify until a Subscriber subscribes to the Publisher. That is to say, it makes the function "lazy."

此方法可以指定直到一个Subscriber订阅Publisher时，才执行特定的方法，换句话说，可以延迟加载


public void subscribeActual(Subscriber<? super T> s) {
    DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<>(s);
    s.onSubscribe(deferred);

    T t;
    try {
        // 执行callable.call方法
        t = Objects.requireNonNull(callable.call(), "The callable returned a null value");
    } catch (Throwable ex) {
        Exceptions.throwIfFatal(ex);
        if (deferred.isCancelled()) {
            RxJavaPlugins.onError(ex);
        } else {
            s.onError(ex);
        }
        return;
    }
    // 将执行结果发送出去
    deferred.complete(t);
}

public final void complete(T v) {
    int state = get();
    for (;;) {
        if (state == FUSED_EMPTY) {
            value = v;
            lazySet(FUSED_READY);

            Subscriber<? super T> a = downstream;
            // 把事件发送给订阅者
            a.onNext(v);
            if (get() != CANCELLED) {
                // 发送完成事件
                a.onComplete();
            }
            return;
        }

        // if state is >= CANCELLED or bit zero is set (*_HAS_VALUE) case, return
        if ((state & ~HAS_REQUEST_NO_VALUE) != 0) {
            return;
        }

        if (state == HAS_REQUEST_NO_VALUE) {
            lazySet(HAS_REQUEST_HAS_VALUE);
            Subscriber<? super T> a = downstream;
            a.onNext(v);
            if (get() != CANCELLED) {
                a.onComplete();
            }
            return;
        }
        value = v;
        if (compareAndSet(NO_REQUEST_NO_VALUE, NO_REQUEST_HAS_VALUE)) {
            return;
        }
        state = get();
        if (state == CANCELLED) {
            value = null;
            return;
        }
    }
}

FlowableFromArray


Converts an array into a {@link Publisher} that emits the items in the array.


把一个数组转换成一个Publisher，然后发送数组里面的每个元素,当数组长度为1时，等效于just方法


public final void request(long n) {
    if (SubscriptionHelper.validate(n)) {
        if (BackpressureHelper.add(this, n) == 0L) {
            if (n == Long.MAX_VALUE) {
                fastPath();
            } else {
                slowPath(n);
            }
        }
    }
}

void slowPath(long r) {
    long e = 0;
    T[] arr = array;
    int f = arr.length;
    int i = index;
    Subscriber<? super T> a = downstream;

    for (;;) {

        while (e != r && i != f) {
            if (cancelled) {
                return;
            }

            T t = arr[i];

            if (t == null) {
                a.onError(new NullPointerException("The element at index " + i + " is null"));
                return;
            } else {
                // 循环发送事件给downstream
                a.onNext(t);
            }

            e++;
            i++;
        }

        if (i == f) {
            if (!cancelled) {
                // 数组事件都发送完后，
                a.onComplete();
            }
            return;
        }

        r = get();
        if (e == r) {
            index = i;
            r = addAndGet(-e);
            if (r == 0L) {
                return;
            }
            e = 0L;
        }
    }
}


FlowableFromIterable

Converts an {@link Iterable} sequence into a {@link Publisher} that emits the items in the sequence.


实现fromarrsy类似，可以用来实现状态机

FlowableGenerate

有时，数据源是同步的(blocking)和取的方式，被转换成响应式时，我们调用get或read方法来获取下数据源中的下一块。当然，可以使用Iterable,但是当源和某些资源关联时，当downstream在资源关闭前停止订阅的时， 可能会导致资源泄露

在RxJava里面，处理这些场景，提供了generate工厂方法族

通常，generate使用3个callback

第一个callback 允许创建一个 per-subscriber state,

第二个callback 获取state对象，然后提供一个输出Observer，onXXX方法可以被调用来发送事件。这个回调会执行downstream的request，最多只能调用onNext一次，可选后跟onError或onComplete

第三个callable,处理downstream unsubscribe事件或前一个callback的结束事件，可以在这个里面释放资源


从JVM和lib库里面很多方法调用，会跑出checked exception,需要用try/catch包起来，此类中的函数接口不支持抛出checked exception



FlowableCreate 


有时，数据源被封装成Flowable的时候，里面的API不支持backpressure(如异步网络请求)。Rxjava里面提供了create(emitter)工厂方法，包含2个参数

一个callback，该回调将针对每个传入的subscriber调用Emitter<T>接口

一个BackpressureStrategy策略，同onBackpressureXXX类似

当前不支持非BackpressureStrategy之外的策略

Emitter使用起来很简单，直接调用其onNext/onError/onComplete

