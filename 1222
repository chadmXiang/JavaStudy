
EventListener  可以用来获取http call的调用数量，使用EventListener可以监听

应用内部调用Http call的大小和频率，当调用Call太多次或Call太大，应该了解这些情况
在当前网络情况下的性能，如果网络性能不够好，应该增强网络或减少调用


Interceptor 是一个功能强大的机制，可以监听、重写、重试Call

OkHttp 中的拦截器分为 Application Interceptor（应用拦截器） 和 NetWork Interceptor（网络拦截器）两种，支持自定义，注册方式的区别：
通过调用 OkHttpClient.Builder 的 addInterceptor() 方法来注册应用拦截器
通过调用OkHttpClient.Builder 的 addNetworkInterceptor() 方法来注册网络拦截器

2个可以自定义的Interceptor，5个内置的Interceptor

1.Application Interceptor：每次网络请求它只会执行一次拦截，而且它是第一个触发拦截的，这里拦截到的url请求的信息都是最原始的信息

2.RetryAndFollowUpInterceptor 的作用，一个负责失败重连的拦截器。它是 Okhttp 内置的第一个拦截器，通过 while (true) 的死循环来进行对异常结果或者响应结果判断是否要进行重新请求。

3.BridgeInterceptor 为用户构建的一个 Request 请求转化为能够进行网络访问的请求，同时将网络请求回来的响应 Response 转化为用户可用的 Response

4.CacheInterceptor 根据 OkHttpClient 对象的配置以及缓存策略对请求值进行缓存

5.ConnectInterceptor 在 OKHTTP 底层是通过 SOCKET 的方式于服务端进行连接的，并且在连接建立之后会通过 OKIO 获取通向 server 端的输入流 Source 和输出流 Sink

6.NetWork Interceptor：它位于倒数第二层，会经过 RetryAndFollowIntercptor 进行重定向并且也会通过 BridgeInterceptor 进行 request请求头和 响应 resposne 的处理

7.CallServerInterceptor 在 ConnectInterceptor 拦截器的功能就是负责与服务器建立 Socket 连接，并且创建了一个 HttpStream 它包括通向服务器的输入流和输出流


retrofit CallAdapter

默认情况下，create方法会创建一个响应式类型，在后台线程里面异步执行一个http请求，有2种方式可以指定运行的线程
使用createSynchronous()，然后调用subscribeOn在想要运行的Scheduler上
使用createWithScheduler来提供一个默认的订阅Scheduler

By default, create() will produce reactive types which execute their HTTP requests asynchronously on a background thread. There are two other ways to control the threading on which a request occurs:
Use createSynchronous() and call subscribeOn on the returned reactive type with a Scheduler of your choice.
Use createWithScheduler(Scheduler) to supply a default subscription Scheduler.
