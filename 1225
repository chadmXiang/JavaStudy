编码

OKio简介

okio

Okio是一个实现java.io和java.nio的库，更方便访问、存储和处理数据。作为OkHttp组件的一部分，在Android中引入支持HTTP的客户端

ByteString 代表一个不可变的字节序列。对于char数据，String是基础类型。
Buffer 可变的字节序列，像ArrayList，读写Buffer的操作与queue类似，从尾部写，从头部读，不需要管理position/limit/capacities

在内部实现，ByteString和Buffer做了一些优化来节约CPU和内存，如果把一个UTF-8字符串编码为ByteString，保存了一个引用，后面如果需要解码的时候可以直接使用，在encodeUtf8方法里面

Buffer被实现为一个segment链表，当你从一个Buffer移动数据到另外一个Buffer的时候，重新设置了segment的所属Buffer，没有直接copy一份数据，在多线程场景下很有帮助
class Buffer implements BufferedSink,BufferedSource


Source and Sink 移动数据
在okio里面，有自己的stream类型
Source：提供字节流，使用此接口可以从任意地方读取数据，如network,storage,或者是内存中的buffer.可以对源进行分层以转换提供的数据，例如解压缩、解密或删除协议帧,大部分应用不会直接操作一个Source，而是使用BufferSource，更简单高效，可以使用Okio.buffer(Source)把一个Source封装为BufferedSource。
此接口功能类似于InputStream，

Source里面没有提供类似available()方法，对应的调用者可以用require方法指定需要多个byte

Sink：接收字节流，使用此接口可以写数据，往network、storage、或内存中的Buffer.Sink可以分层以转换接收的数据，例如压缩、加密、限制或添加协议帧。大部分应用不会直接操作一个Sink，而是使用BufferSink，更简单高效，可以使用Okio.buffer(Sink)把一个Sink封装为BufferedSink。

使用方式类似于OutputStream



主要差异：
提供了IO语义层面的超时
容易实现 ，容易使用
没有人为区分字符流和字节流，都作为数据处理，读写都按字节来操作
容易测试

Buffer and ByteString 持有数据

Buffer 内部保存的数据在Segment Pool里面

BufferedSource and BufferedSink 更高效的移动数据


Hash和加解密

提供了2种InflaterSource/DeflaterSink GZipSink/GZipSource 2种压缩方式

HashingSink 提供了支持各种算法计算Hash


使用，从text文件、binary文件，socket


okio 几大核心点

Source和Sink的概念

ByteString和Buffer的概念

简单的使用方法

Segment pool管理数据移动的原理

TimeOut AsyncTimeout

Throttler


Segment

Segment 在Buffer里面是环形双链表，在SegmentPool里面是单链表

保存在Segment里面的byte数组可能被buffer和bytestring共享，当shared为true时，当前的segment既不能被回收，也不能被改变。唯一的例外是，当前Segment的owner可以在Segment里面添加数据，写入数据到limit或超出这个位置

对于每个byte数组，只有唯一的所属的segment。

position/limits/prev/next 是不共享的

int SIZE = 8192 segment里面byte数据的默认大小

int SHARE_MINIMUM = 1024 当segment里面的byte数据大小超过这个值时，segment会变成共享的，来避免复制数据


final byte[] data segment里面保存的数据，初始化后不能改变大小

int limit 指向segment的可写的起始位置

int pos 指向segment可读的起始位置

boolean shared 是否和其它segment或bytestring共享data数组，为true时表示共享

boolean owner 是否拥有byte数组，为true时表示这个segment拥有数组，可以进行写入

Segment next; 当前segment的下一个segment

Segment pre; 当前segment的前一个segment

读的时候，先从InputStream里面读取8192大小的字节到一个Segment里面，head节点指向这个Segment,如果要读取的字节数大于Buffer里面的大小，则继续读取一个8192大小，直到Buffer大小超过要读取的字节数

写的时候，情况要复杂一些：

不浪费CPU
复制大量数据是很消耗资源的操作，相反，在Okio里面，会把整个segment重新设置所属关系，从source buffer到target buffer

不浪费内存

作为不变变量，Buffer中相邻的Segment对应容量至少满50%，head和tail节点除外。

head segment不能维持不变性，因为应用会从消费这个segment里面的数据，降低容量

tail segment不能维持不变性，因为应用会从这个segment里面新增数据，可能需要一个完整的空Segment作为tail添加

在2个buffer之间移动segment

当从一个BufferA写数据到另外一个BufferB,Okio更倾向于修改整个segment的所属于关系，而不是复制数据

如果BufferA里面[72%]写入BufferB里面[91%, 61%]，则直接修改BufferA里面的segment指向，BufferB[91%, 61%, 72%]

如果BufferA里面[99%, 3%]写入BufferB[100%, 2%]，则修改指向，BufferB[100%, 2%, 99%, 3%]

当合并buffer的时候，BufferA[30%, 80%] 写入BufferB[100%, 40%]，结果是BufferB[100%, 70%, 80%]

拆分segment:当只将source buffer的一部分写入到sink buffer里面时，比如说将source [92%, 82%]写30%到sink [51%, 91%] ，先拆分source的head segment,source变成[30%, 62%, 82%],修改source的head指向为sink的tail，sink变成[51%, 91%, 30%] 

从source的head节点开始移动byte数据到当前Buffer的tail
public void write(Buffer source, long byteCount)



如果要写入的byteCount小于source里面head节点的当前容量

如果能直接写入当前Buffer的tail节点，则直接写入并返回

如果不能写入当前Buffer的tail节点，则把source的head节点拆分成2个segment,然后移动第一个segment到当前Buffer,也分2种：

	如果byteCount >= SHARE_MINIMUM 则创建一个共享的segment,shared值为true

	如果byteCount < SHARE_MINIMUM，则从SegmentPool里面取一个Segemnt，

经过上面的操作后，source的head节点变成了新创建的segment


获取source的head节点作为要移动的segent,然后修改head的指向为其后继节点，分2种情况：
	
	如果要移动的segment后继节点为空，则修改指向为head本身

   如果非空，source head添加到当前buffer的tail,然后检查当前tail和前驱节点是否可以合并

		如果prev节点的容量小于tail节点的数据容量，则直接返回，不能合并

          如果大于或等于，则把tail节点的内容写入到prev节点里面，修改节点指向，最后回收tail节点

修改source和当前buffer的大小，以及要写入的byteCount，重复上面的操作


SegmentPool

管理一个Segment链表，其中next表示head节点

long MAX_SIZE = 64 * 1024; // 64 KiB


Segment next


long byteCount  pool里面的byte数据大小

take()方法，取链表里面的head节点，如果next为空，则创建一个新的Segment；如果非空，把返回head节点result，并修改next指针为result.next，result.next为空，并修改容量byteCount

recycle()方法，将要回收的Segment作为head节点加入，同时修改byteCount容量，重置此segment的pos和limit,如果超出了最大容量，则忽略，此Segment会被JVM回收

如果segment是共享的，则直接返回，不能加入，
